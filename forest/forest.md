# Слайд 1. Приветствие

![preview](./preview.jpg)

Здравствуйте, меня зовут Катя и я бы хотела рассказать о книге из серии You Don't Know JS, "Up & Going".

Это замечательная вводная в программирование книга. Ее прочтение позволит сразу же начать писать код на одном из самых популярных и выразительных языков программирования - JavaScript. "Up & Going" лаконичная, но в тоже время простая и понятная книга, дающая необходимые и достаточные знания для старта в мире программирования.
Она состоит всего из 3 небольших глав, последняя из которых - оглавнение описания других книг и всей серии You Don't Know JS.
Другие же две главы, определяющие суть книги это:

- введение в основы программирования: выражения, компляция и интепретация; 
- и структура компьютерных программ: циклы, операторы, функции, ввод и вывод, работа с пользователем и так далее.


Начинает свой рассказ книга с такой базовой конструкции как выражения.

# Слайд 2. Выражения

Выражение - это любая ссылка на переменную или значение, или набор переменных и значений, обьединенных операциями.

Для наглядности можно рассмотреть простой пример выражения: 

```javascript
    a = b * 2.
```

Оно легко читается и интуитивно понятно для человека. Любой разработчик сразу же может разбить его на логические части:

- a, b - это переменные, которые выступают как имена или места для хранения значений (такое определение верно по крайней мере для языков с функциональной парадигмой, поддерживаемой в JavaScript);
- 2 - литерал, то есть фиксированное значение;
- а символы '=' и '\*' - операции (схожи с математическими, но все же имеющие отличия).

Это отлично, но сама машина не может исполнить такое выражение. Оно сложно для него, ему необходим только объектный код.
В свою очередь, машинный код трудно понять человеку и чтобы реализовать машине мысли человека, выраженные с помощью высокоуровеных конструкций, разработали специальные инструменты - **компиляторы** и **интерпретаторы**.

# Слайд 3. Компиляция и интепретация
 *показать картинками компиляцию и интерпретацию*
- Компиляция - это заранее выполняемый перевод инструкций языка программирования в объектный код. После компиляции мы получаем уже готовую программу, способную исполняться машиной.

- Интепретация же - это построчный перевод и исполнение машиной инструкций языка программирования непосредственно во время выполнения программы. Чтение кода машиной осуществляется сверху-вниз.

Кстати, некоторые разработчики утверждают, что JavaScript - интерпретируемый язык, так как исходный код обрабатывается каждый раз при запуске программы. На самом деле, движок JavaScript (V8) компилирует код во время выполнения, так называемая JIT-компиляция, а затем сразу же исполняет полученный код.

Итак, каждый раз при написании кода, мы создаем определенные конструкции - выражения на высокоуровневом языке переводимые для исполнения в машинный код.

Язык программирования, в нашем случае JavaScript, всегда предоставляет необходимый базовый набор конструкций для построения программ. И первое, с чего следует начинать рассмотрение произведение каких-либо операций - это то, с чем работать, с чем производить эти самые операции. С типов данных.

# Слайды 4-5. Типы данных

Типы данных в JavaScript разделяются на две категории: примитивы и объект (Object). То есть простые и сложные типы данных.

Притимивы. К ним относятся:

- числа `const a = 1 `
- строки `const str = "hello"`
- boolean - логический тип (true/false) `const bool = true`
- undefined - специальный тип для неопределенных переменных, то есть таким, которым не присвоено значение.
- null (typeof null === [object][Object]) - еще один специальный тип...//дописать

А Объект (не конструктор Object) — это структура данных, представленная в виде набора пар «ключ-значение». Значением, или свойством объекта, может быть любой тип данных, как примитив, так и объект, например функция (тогда она будет называться методом). Важно отметить, что с помощью констуктора Объекта можно создавать новые объекты. Например так созданы объекты-обертки для чисел и строк. Object - главный строительный блок в JavaScript. Подробнее мы рассмотрим объекты еще немного в этом докладе и продолжим его исследование в последующем.

Важно отметить, JavaScript - это язык с динамической типизацией (ducktyping). Объявлять тип данных переменной не нужно, комплятор сам определит тип по хранимому значению переменной. 

Второе необходимое - это как-то говорить компилятору что мы хотим совершить с переменными того или иного типа, то есть произвести с ними операцию. Такие действия называются операторами.

# Слайды 6-8. Операторы
В JavaScript поддерживаются все основыне операторы, как и в других языках программирования. Их можно классифицировать по назначению, а так же по самой конструкции, то есть по количеству операндов.
Операнд - это то, к чему применяется оператор. Иными словами - это аргумент оператора. По количеству операндов можно разделить на: **унарный**, **бинарный** и **тернарный**.
То есть на оператор с одним операндом, двумя и тремя соответственно.
Так же операторы бывают универсальными. И могут быть применимы как в качестве унарного, так и в качестве бинарного.

По назначению же их классификация гораздо шире:

- присваивание - // написать определение
- конкатенация - имеется ввиду сложение строк
- запятая - оператор для перечисления выражений
- математические - те, что известны нам со школы, +, -, * и так далее
- побитовые - работающие непосредственно с двоичным представлением
- составные - операции, которые объединяют математическую операцию с присваиванием.
- инкремент и декремент - увеличение и уменьшение значения переменной на единицу.
- сравнения - так же известны из курса школьной математики. больше, меньше и тому подобные.  Однако, стоит выделить такие операторы как нестрогое и строгое равенство. О них я расскажу чуть позднее.
- логические - и, или...
- комментарии - строки, игнорируемые компилятором, в большинстве случаев нужных только разработчикам, но часто их используют и для инструментов, например для генерации документации по коду.
 
Рекомендации к созданию комментария:
*Не писать слишком много. должны объяснять "почему", а не "что", или же "как", когда код особенно сложен.
Однострочный игнорируется до конца строки, в отличии от многострочного, который можно завершить в любом месте.*

Отдельно стоят операторы объявления и доступа к свойству объекта:

- объявление - может быть одним из трех типов: var, let, const (они имеют различия, но сейчас нам это неважно)

- доступ к свойству объекта - пожалуй самый часто используемый оператор в объекто-ориентированной парадигме. Он говорит сам за себя, а его конструкция - всего лишь точка. Как пример: 

```js
    console.log();
``` 
*console* - это объект, а *log* - его свойство, в данном случае метод объекта. 

Важно помнить, что операторы имеют разный приоритет исполнения. Таблицу приоритетов можно посмотреть на "ссылка". Кроме приоритета выполнения, логично предположить, что операции выполняются только для опредленных типов данных. И это верно. Действительно, невозможно вычесть из null число, но мы могли бы представить null как другой тип данных, как число.
Так как JavaScript обладает динамической типизацией, то он проводит конвертации автоматически, то есть приводит один тип данных к другому для возможности исполнения кода. Однако, часто приведение типов выглядит довольно странным для разработчиков, поэтому выделяют два способа приведения:


# Слайд 9. Приведение типов

- явное - очевидное, не заставляющее разработчика думать, например Number("10")
- и неявное - приведение с использованием особенностей поведения языка, часто может вводить разработчиков в замешательство, например true & false;

*В JavaScript, кстати, есть строгий список ложных значений, все остальные являются истинными*

С приведением типов постоянно сталкиваются, как очевидно, при сравнении двух значений. Особенно это интересно в контексте JavaScript.

# Слайд 10. Сравнение с разными типами

Пожалуй, самые часто используемые операторы сравнения - это равенство. В JavaScript есть два отличных по своему поведению оператора:
- строгое равенство 
- строгое неравенство
Оба этих оператора не используют приведение типов, потому их так и назвали **строгое**.

*Многие разработчки предпочитают избегать нестрогое равенство для предотвращения неожиданных ситуаций. Явное лучше неявного*

В остальных случаях, будь то сравнение двух примитивом или примитива с объектом, будет использовано приведение типов. Так, например, пустой объект будет больше, чем непустая строка.

```js
    ({}) > "It's amazing!" // true
```
 
Еще одним важным моментом является сравнение не примитивных значений. Объекты сравниваются по ссылке, то есть если сравнивать два объекта с разными ссылками, но с одинаковыми свойствами, то компилятор посчитает их неравными. Об этом никогда не стоит забывать, работая с JavaScript.

```js
    ({ name: 'Ann' }) == ({ name: 'Ann' }) // false
```
Сейчас мы не будем рассматривать разные способы приведения. Но мы обязательно к ним вернемся в следующий раз.
Итак, мы рассмотрели достаточно много и время подвести краткий, промежуточный итог.

# Cлайд 11. Заголовок???
На текущий момент мы имеем такие возможности:
- объявление переменных, хранящие разные типы значений: притивы и объекты
- совершение действий над переменными - операции, включая доступ к свойствам объектов
- приведение значений с разными типами данных
- сравнения

Этого уже достаточно для произведения некоторых вычислений. Но такой высокоуровневый язык как JavaScript, предоставляет гораздо больше конструкций для построения гибких, масштабируемых и функциональных программ.

Согласитесь, было бы, например, удобно, если программа могла применять те или операции в зависимости от значения переменной. Как если бы мы поступали в жизни при выборе даже тех же самых продуктов питания: съесть ли сладкое или соленое. Или делать что-то пока не изменится условие. И JavaScript имеет такие возможности, раскрывающиеся в Условных операторах (Conditional Statement) и Циклах (Loop Statement).

# Слайды 12. Условные операторы. // Дополнить

Условные операторы позволяют выбирать то или иное действие исходя из значения операнда. Такие конструкции делают язык невероятно гибким и, конечно, есть в любом высокоуровневом языке.

В JavaScript есть два вида условных конструкцией:

# Слайд 13. Условные операторы. If
`if`, `else if`, `else` - многим известная инструкция из других языков. Исполняется она совершенно так, как и написано. "Если это так" делать то-то, "иначе если" делать вот так, "иначе" так. В JavaScript она довольно интересная.

```js
   if(something) {
    doSomething()
   } else if(something < 0) {
    doStuff()
   } else {
    foo()
   }
```

Во-первых, можно не использовать `else if` и `else` без необходиости, строя лаконичных конструкции `if` в строке.
```js
    if(something) doSomething();    
```

Во-вторых, все же остается возможность использовать сложную инструкцию с большим количеством вариантов, так как операторов `else if` может быть сколько угодно;

```js
   if(something) {
    doSomething()
   } else if(...) {...}
   ...
   else if(...) {...} else {
    foo()
   }    
```
# Слайд 14. Условные операторы. Switch
`Switch` - вторая конструкция. Чаще всего она используется в случае сложного алгоритма. Switch упрощает организацию выбора по значению, предоставляя оператор case. 

```js
    switch(prop) {
        case 0: ...
            break; // прервывает выполение
        case 1: ...
            break;
        ...
        default: ... // выбор по умолчанию - если не подходит ни один case 
    }
```

Кроме того, для больших инструкций выбора, `switch` гораздо предпочтительнее. С его помощью можно полностью повторить поведение `if statement`: если заместо `if` и `else if` используется `case`, то вместо `else` - оператор `default` (выбор по умолчанию).
Так же, `switch` не уступает в гибкости, если мы хотим выбрать несколько вариантов, то мы просто не должны указывать в `case` оператор `break` (оператор прерывания);

```js
    switch(prop) {
        case 0: ...;
        case 1: ...;
        ...
        default: ... // выбор по умолчанию - если не подходит ни один case 
    }
```

Итак, для алгоритмов, предполагающих большой выбор надо использовать `switch`, а для других `if`? Да, но можно немного увеличить наш арсенал:

# Слайд 15. Условные операторы. Advanced
 - **тернарный оператор** выбора - заменяет собой два оператора: `if` и `else`
    ```js
        x > y ? 'x is biggest' : 'y is biggest' 
    ```
 - **pattern matching**, о котором сейчас речь не пойдет:)

Теперь перейдем ко второму необходимому виду инструкций - циклам.

# Слайд 16. Циклы

Кратко и просто определить циклы можно как повторение какого-либо действия пока верно условие. Более сложный термин, являющийся синонимом к *циклу* - *итерация, с лат. повторяю*.

В JavaScript есть несколько видов циклов:
- for - особенный цикл с возможностью задания шага, обновляющегося при каждой итерации
 ```js
    for (let i = 0; i < 10; i++) { // проверка условия в начале
        ...
    }
 ```
- do-while
   ```js
      do {
        ...
      } while (i < 10) // проверка условия в конце
   ```
- while
   ```js
      while (i < 10) { // проверка условия в начале
        ...
      } 
    ```
Все эти три вида цикла концептуально работают одинаково: пока условие верно, действие повторяется. Если же условие ложно - осуществляется выход из цикла, то есть цикл завершится.

Так же  можно добавить, что для всех циклов одинаково действуют операторы `break` и `continue` (осуществляет переход к следущему шагу итерации). Эти два оператора могут использоваться с меткой - оператором `label`, ссылающимся на какое-то место в программе, и, соответственно прерывать выполнение отмеченного выражения или перейти к нему.

Циклы позволяют сократить код, предотвращая ненужное дублирования одних и тех же действий.

Прекрасно, теперь у нас, кажется, есть все, чтобы строить сложные программы. Как ни странно, это так. Но построение сложных программ - это большое число кода, инструкций. Наверно, ни один разработчик не справится со сложным проектом без дополнительных возможностей. Каких -  сейчас узнаем.

# Слайд 17. Прототипное наследование

Прототипное наследование - недооцененный механизм JavaScript. Как понятно, это вид наследования основанный на цепочке прототипов.
Что такое прототип?
```
   Прототип - это объект, предоставляющий разделяемые свойства для других объектов
```
Соответственно, цепочка прототипов - это объекты разделяющие свойства общего объекта, который разделяет свойства более старшего объекта и так далее, пока. Как это работает?
*// показать картинку*

Каждый объект содержит ссылку на свой прототип, то есть тот объект (объект-прототип), свойства которого он разделяет. У объекта-прототипа также есть свой собственный прототип и так далее до тех пор, пока цепочка не завершится особым примитивом `null`, не имеющего прототипа.

Такая модель наследования может выглядеть странно для программистов, работавших с классическими объектно-ориентированными языками, такими как Java, C#. Но она по-настоящему мощная, засчет наследования всех разделяемых свойств объектов-прототипов.

О применении наследования можно говорить очень долго, рассматривая объектно-ориентированный и функциональный стили, а так же паттерны проектирования. Эти темы будут затронуты в дальнейших темах других других книг серии **You Don't know JS**.

А сейчас самое время рассмотреть еще один мощный инструмент JavaScript - *функции*.

# Слайд 18. Функции

*Функция - это зависимость переменной функции от ее аргумента*.

Для JavaScript такое определение не всегда верно, так как она может не содержать аргументов или не использовать аргумент для получения результата.

Можно дать другое определение
*Функция - это программный блок, спопобный принимать любое количество входных данных, производить внутри себя расчет результата и возвращать его*.

По факту же, функция это экземпляр Объекта, то есть прототипом функции является Объект. Потому она имеет все свойства Объекта и позволяет создавать новые сущности (становясь прототипом), а не только производить вычисления и сокращать код посредствам переиспользования. Функции - основной строительный блок.

Функция как конструктор: `fucntion Foo() {this.bar = true;}; const foo = new Foo()`


# Слайд 19. Функции. Способы объявления

Существует два способа объявления функций:
- Function declaration - функция, объявленная в основном потоке кода
   ```js
    function foo(args) {...}
   ```
- Function expression - объявление функции в контексте какого-либо выражения
   ```js
    const foo = function(args) {...}
    ```
Способы одинаково объявляют функцию, но по-разному воспринимаются компилятором. Если *Function declaration* производится до выполнения кода, то *Function expression* в процессе выполения выражения.

Оба примера - примеры с именованными функциями. Однако, функции могут быть так же безымянными, то есть *анонимными*. Такие функции часто используются, например, в коллбэках, когда мы уверены, что не потребуется повторный вызов этой функции.   

На самом деле, есть еще третий способ объявления функции с использованием конструктора:
  ```js
  const foo = new Function(...);
  ```
Такой способ используется довольно редко, так как он неудобен и таит в себе некоторые опасности (тело функции записывается строкой).

Как видно из опеределений, функции может объявляться в основном потоке, быть свойством какого-либо объекта, передаваться как коллбэк и даже быть функцией-конструктором. Из такого разного применения функции логично возникает вопрос к чему применяется функции, то есть чьим свойством она является.


# Слайд 20. Функции. Контекст выполнения

На вопрос "чья это функция?" отвечает контекст выполнения функции, *this*. This всегда указывает на объект. Условно, можно разделить поведение this по трем типам:

  - Глобальный контекст - this ссылается на глобальный объект
     ```js
        function foo() { return this; }
        foo() // window 
     ```
  - Функция-конструктор(new Foo()) - this связано с создаваемым новым объектом. Если же не создавать новый объект (без new), то контекст будет глобальным
      ```js
        function Foo() { this.bar = function() {return this;} }
        const foo = new Foo();
        foo.bar() // Foo 
      ```
  - Метод объекта - this указывает на объект, в котором был вызван метод (так же справедливо для цепочки прототипов)
      ```js
        const obj = { foo: function() { return this } };
        obj.foo() // obj
      ```
Это не все возможные типы применения функции, но благодаря им можно легко понять контекст и в других случаях.
*Примечаение: Контекст функции переопределеть с помощью методов call и apply, передавая его явно в качестве аргумента*

Внутри функции могут быть объявленые различные переменные и даже другие функции, что и делает функцию мощным инструментом. За переменные внутри функции отвечает Область видимости.  

# Слайд 21. Функции. Область видимости

Область видимости (лексическое окружение) - это коллекция переменных и правила доступа к ним. Доступ к переменным осуществляется по имени.

Объявленные в функции доступны только в самом теле функции и недоступные за ее пределами.
Вложенные функции так же имеют доступ к переменным родительской функции

```js
    function foo() {
        let x = 1; 
        function bar() {
            let y = 1 + x;
        }
        y + x; // Referrence Error
    }
```
// связать с слайд 22
# Слайд 22. Функции. Замыкания

// завершить. перейти к итогам и вопросам